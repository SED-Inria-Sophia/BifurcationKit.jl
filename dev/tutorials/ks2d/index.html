<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2d Kuramoto–Sivashinsky Equation on GPU (Advanced) · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../plotting/">Plotting</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../../periodicOrbitCollocation/">Collocation</a></li><li><a class="tocitem" href="../../periodicOrbitShooting/">Shooting</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Symmetries / Waves</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../intro_wave/">Introduction</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../../PALC/">PALC</a></li><li><a class="tocitem" href="../../MooreSpence/">Moore Spence Continuation</a></li><li><a class="tocitem" href="../../DeflatedContinuation/">Deflated Continuation</a></li></ul></li><li><a class="tocitem" href="../../EventCallback/">Event Handling and Callback</a></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Bifurcations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../../deflatedproblem/">Deflated problems</a></li><li><a class="tocitem" href="../../constrainedproblem/">Constrained problem</a></li><li><a class="tocitem" href="../../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>2d Kuramoto–Sivashinsky Equation on GPU (Advanced)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>2d Kuramoto–Sivashinsky Equation on GPU (Advanced)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/tutorials/ks2d.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="d-Kuramoto–Sivashinsky-Equation-on-GPU-(Advanced)"><a class="docs-heading-anchor" href="#d-Kuramoto–Sivashinsky-Equation-on-GPU-(Advanced)">2d Kuramoto–Sivashinsky Equation on GPU (Advanced)</a><a id="d-Kuramoto–Sivashinsky-Equation-on-GPU-(Advanced)-1"></a><a class="docs-heading-anchor-permalink" href="#d-Kuramoto–Sivashinsky-Equation-on-GPU-(Advanced)" title="Permalink"></a></h1><ul><li><a href="#d-Kuramoto–Sivashinsky-Equation-on-GPU-(Advanced)">2d Kuramoto–Sivashinsky Equation on GPU (Advanced)</a></li><li class="no-marker"><ul><li><a href="#Structures-for-inplace-fft">Structures for inplace fft</a></li><li><a href="#Code-for-the-functional">Code for the functional</a></li><li><a href="#Code-for-the-jacobian">Code for the jacobian</a></li><li><a href="#Newton-iterations-and-deflation">Newton iterations and deflation</a></li></ul></li></ul><div class="admonition is-category-unknown"><header class="admonition-header">References</header><div class="admonition-body"><p>The following example is exposed in Evstigneev, Nikolay M., and Oleg I. Ryabkov. <strong>Bifurcation Diagram of Stationary Solutions of the 2D Kuramoto-Sivashinsky Equation in Periodic Domains.</strong> Journal of Physics: Conference Series 1730, no. 1 2021</p></div></div><p>Here we give an example where the <strong>bifurcation diagram</strong> (not just the continuation) can be done <strong>entirely</strong> on the GPU, <em>e.g.</em> on a single V100 NIVDIA.</p><p>We choose the 2d Kuramoto–Sivashinsky Equation as an example on the 2d torus.</p><p class="math-container">\[-\alpha\left(u u_{x}+u u_{y}+\Delta u\right)- \Delta^{2} u=0,\quad x \in \mathbb{T}^{2}.\tag{E}\]</p><p>For the Newton algorithm, we need to solve the linear system in <span>$v$</span>:</p><p class="math-container">\[-\alpha\left(v u_{x}+ v u_{y}+2 u v_{x}+ u v_{y}+\Delta u\right)- \Delta^{2} v = rhs.\]</p><p>The conditioning of the jacobian is not good enough to have fast convergence. However, the above problem is equivalent to:</p><p class="math-container">\[v + L \cdot (A \cdot v) = L\cdot rhs\]</p><p>where</p><p class="math-container">\[L := -(\Delta^2-\alpha\Delta)^{-1}\]</p><p>is very well conditioned and</p><p class="math-container">\[A\cdot v := -\alpha\left(v u_{x}+v u_{y}+u v_{x}+u v_{y}\right) = -\alpha\nabla\cdot (uv).\]</p><p>Hence, to solve the previous equation, only a <strong>few</strong> GMRES iterations are required.</p><blockquote><p>In effect, the preconditioned PDE is an example of nonlocal problem.</p></blockquote><h2 id="Structures-for-inplace-fft"><a class="docs-heading-anchor" href="#Structures-for-inplace-fft">Structures for inplace fft</a><a id="Structures-for-inplace-fft-1"></a><a class="docs-heading-anchor-permalink" href="#Structures-for-inplace-fft" title="Permalink"></a></h2><p>The issue now is to compute <span>$L$</span> but this is easy using Fourier transforms.</p><p>The <strong>periodic</strong> boundary conditions imply that the Fourier transform symbol associated to <span>$L$</span> is</p><p class="math-container">\[l_1 = \alpha k_x^2+\alpha k_y^2+(kx^2+k_y^2)^2\]</p><p>which is pre-computed in the composite type <code>SHLinearOp</code>. Then, the effect of <code>L</code> on <code>u</code> is as simple as <code>real.(ifft( l1 .* fft(u) ))</code> and the inverse <code>L\u</code> is <code>real.(ifft( fft(u) ./ l1 ))</code>. However, in order to save memory on the GPU, we use inplace FFTs to reduce temporaries which explains the following code.</p><pre><code class="language-julia hljs">using Revise
using AbstractFFTs, FFTW, KrylovKit, Setfield, Parameters
using BifurcationKit, LinearAlgebra, Plots
const BK = BifurcationKit

# the following struct encodes the operator L1
# Making the linear operator a subtype of BK.AbstractLinearSolver is handy 
# as it will be used in the Newton iterations.
mutable struct KSLinearOp{TX, Treal, Tcomp, Td1, Td2, Td4, Tsymbol, Tplan, Tiplan, Tm} &lt;: BK.AbstractLinearSolver
	X::TX					# x grid
	Y::TX					# y grid
	tmp_real::Treal         # temporary with real values
	tmp_complex::Tcomp      # temporary with complex values
	d1::Td1					# contains symbol for ∂
	d2::Td2					# contains symbol for ∂^2
	d4::Td4					# contains symbol for ∂^4
	symbolMul::Tsymbol
	symbolDiv::Tsymbol
	fftplan::Tplan		# FFT plan
	ifftplan::Tiplan	# inverse FFT plan
	periodic::Bool		# periodic BC?
	mask::Tm		# mask to invert L
	applymask::Bool		# apply the mask?
end

function KSLinearOp(N, l; AF = Array{TY})
	Nx, Ny = N
	lx, ly = l

	tmpc = AF(Complex.(zeros(Nx, Ny)))

	X = -lx .+ 2lx/Nx * collect(0:Nx-1)
	Y = -ly .+ 2ly/Ny * collect(0:Ny-1)
	# AF is a type, it could be CuArray{TY} to run the following on GPU
	Kx = vcat(collect(0:Nx/2), collect(Nx/2+1:Nx-1) .- Nx)
	Ky = vcat(collect(0:Ny/2), collect(Ny/2+1:Ny-1) .- Ny)
	plan = plan_fft!(tmpc)
	iplan = plan_ifft!(tmpc)

	mask = ones(Nx, Ny); mask[1,1] = 0

	d1 = [ Complex(0,(pi/lx * kx)   + (pi/ly * ky))  for kx in Kx, ky in Ky]
	d2 = [          -(pi/lx * kx)^2 - (pi/ly * ky)^2 for kx in Kx, ky in Ky]
	d4 = d2 .^ 2
	return KSLinearOp(X, Y, AF(zeros(Nx, Ny)), tmpc, AF(d1), AF(d2), AF(d4), 
				AF(4d4+d2), AF(4d4+d2), plan, iplan, true, AF(mask), true)
end

function apply!(out, c::KSLinearOp, u::AbstractMatrix{ &lt;: Real}, multiplier, op = *)
	c.tmp_complex .= Complex.(u)
	c.fftplan * c.tmp_complex
	c.tmp_complex .= op.(c.tmp_complex, multiplier)
	if c.applymask
		# remove the constant component
		# c.tmp_complex[1,1] = 0 # ca casse le calcul des VPs...
		c.tmp_complex .*= c.mask
	end
	c.ifftplan * c.tmp_complex
	out .= real.(c.tmp_complex)
	return out
end
apply(c::KSLinearOp, u, multiplier, op = *) = apply!(similar(u), c, u, multiplier, op)</code></pre><h2 id="Code-for-the-functional"><a class="docs-heading-anchor" href="#Code-for-the-functional">Code for the functional</a><a id="Code-for-the-functional-1"></a><a class="docs-heading-anchor-permalink" href="#Code-for-the-functional" title="Permalink"></a></h2><p>We can use this to encode the equation (E)</p><pre><code class="language-julia hljs">function F_ksfft(u, p)
	@unpack α, L = p
	# update the operator L
	updateMul!(L, α)
	out = similar(u)
	out .= u.^2
	divergence!(out, L, out)
	# uL = L * u
	mul!(L.tmp_real, L, u)
	out .+= L.tmp_real
	out .*= -1
	out
end</code></pre><p>While we are at it, let&#39;s compute the other differentials</p><pre><code class="language-julia hljs"># second differential
function d2F_ksfft(u, p, du1, du2)
	@unpack α, L = p
	# update the operator L
	updateMul!(L, α)
	return -2 .* divergence(L, du2 .* du1)
end

# third differential
d3F_ksfft(u, p, du1, du2, du3) = zero(du1)</code></pre><h2 id="Code-for-the-jacobian"><a class="docs-heading-anchor" href="#Code-for-the-jacobian">Code for the jacobian</a><a id="Code-for-the-jacobian-1"></a><a class="docs-heading-anchor-permalink" href="#Code-for-the-jacobian" title="Permalink"></a></h2><p>Finally, let us encode the jacobian</p><pre><code class="language-julia hljs">mutable struct JacobianKS{Tv, T, Tl}
	u::Tv	# current value of u at which jacobian is evaluated
	α::T	# parameter α
	L::Tl	# operator L
	applySym::Bool # whether to apply the Sym operator 
end

# update the jacobian
function (J::JacobianKS)(u, p)
	# we update the internal field
	J.u .= u
	J.α = p.α
	# update the operator L
	updateMul!(J.L, p.α)
	updateDiv!(J.L, p.α)
	# return the jacobian
	return J
end

# jacobian evaluation
function (J::JacobianKS)(out::T, du::T; _transpose::Bool = false) where T
	α = J.α
	ρ = _transpose ? -2 : 2
	# out = J.L * du
	mul!(out, J.L, du)
	# J.L.tmp_real = ρ .* u .* du
	J.L.tmp_real .= ρ .* J.u .* du
	# J.L.tmp_real = div(J.L.tmp_real)
	divergence!(J.L.tmp_real, J.L, J.L.tmp_real)
	out .= (-1) .* (out .+ J.L.tmp_real)
	return out
end
(J::JacobianKS)(du; _transpose::Bool = false) = (J::JacobianKS)(similar(du), du; _transpose = _transpose)</code></pre><h2 id="Newton-iterations-and-deflation"><a class="docs-heading-anchor" href="#Newton-iterations-and-deflation">Newton iterations and deflation</a><a id="Newton-iterations-and-deflation-1"></a><a class="docs-heading-anchor-permalink" href="#Newton-iterations-and-deflation" title="Permalink"></a></h2><p>We have now everything to solve (E). Let us run a Krylov-Newton algorithm to find non trivial states:</p><pre><code class="language-julia hljs"># size of the interval
_L = 1
# we make it const because we use it for the norms
const N = (2^9, 2^9)
# domain
l = (pi * _L, pi)

# Operator L
# we make it const because we update its parameters
const L = KSLinearOp(N, l; AF = AF)

# Structure to compute eigenvalues
Leig = KSEigOp(L, 0.01) # for eigenvalues computation

# initial guess for Newton
sol0 = 0.5 .* [(cos(x-2.) .+ 0sin(y) ) for x in L.X, y in L.Y] |&gt; AF

# Structure to hold the jacobian
J_ksfft = JacobianKS(copy(sol0), 0., L, true)

# we hold the differentials together
jet = (F_ksfft, J_ksfft, d2F_ksfft, d3F_ksfft)

# parameters for the problem
par = (α = 1/4.005, L = L)

# Linear solver: GMRES with left preconditioner given by L
LsL = GMRESKrylovKit(Pl = L, verbose = 0, dim = 100, maxiter = 5)</code></pre><p>We now run the Krylov-Newton</p><pre><code class="language-julia hljs">opt_new = NewtonPar(verbose = true, tol = 1e-6, linsolver = LsL, eigsolver = Leig)
sol_hexa, hist, flag = @time newton(F_ksfft, J_ksfft,
	(Π(AF(sol0))), par, opt_new,
	normN = x -&gt; norm(x) / sqrt(N[1]*N[2])
	)
println(&quot;--&gt; norm(sol) = &quot;, norminf(sol_hexa), &quot;, mean = &quot;, mean(sol_hexa))

plotsol(sol_hexa)</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.8 on <span class="colophon-date" title="Sunday 17 October 2021 20:14">Sunday 17 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
