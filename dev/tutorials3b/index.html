<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1d Brusselator (advanced user) · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../EventCallback/">Event Handling and Callback</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-12" type="checkbox"/><label class="tocitem" for="menuitem-4-12"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>1d Brusselator (advanced user)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1d Brusselator (advanced user)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/tutorials3b.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="d-Brusselator-(advanced-user)"><a class="docs-heading-anchor" href="#d-Brusselator-(advanced-user)">1d Brusselator (advanced user)</a><a id="d-Brusselator-(advanced-user)-1"></a><a class="docs-heading-anchor-permalink" href="#d-Brusselator-(advanced-user)" title="Permalink"></a></h1><ul><li><a href="#d-Brusselator-(advanced-user)">1d Brusselator (advanced user)</a></li><ul><li><a href="#Normal-form-computation">Normal form computation</a></li><li><a href="#Continuation-of-Hopf-points">Continuation of Hopf points</a></li><li><a href="#Continuation-of-periodic-orbits-(Finite-differences)">Continuation of periodic orbits (Finite differences)</a></li><li><a href="#Deflation-for-periodic-orbit-problems">Deflation for periodic orbit problems</a></li><li><a href="#Floquet-coefficients">Floquet coefficients</a></li><li><a href="#Continuation-of-periodic-orbits-(Standard-Shooting)">Continuation of periodic orbits (Standard Shooting)</a></li><li><a href="#Continuation-of-periodic-orbits-(Poincaré-Shooting)">Continuation of periodic orbits (Poincaré Shooting)</a></li></ul></ul><div class="admonition is-category-unknown"><header class="admonition-header">References</header><div class="admonition-body"><p>This example is taken from <strong>Numerical Bifurcation Analysis of Periodic Solutions of Partial Differential Equations,</strong> Lust, 1997.</p></div></div><div class="admonition is-info"><header class="admonition-header">Goal</header><div class="admonition-body"><p>The goal of this tutorial is to show similar computations as in the previous tutorial but without using the automatic branch switching tools. This is for the experienced used who wants to dive more in the internals of the package.    </p></div></div><p>We look at the Brusselator in 1d. The equations are as follows</p><p class="math-container">\[\begin{aligned} \frac { \partial X } { \partial t } &amp; = \frac { D _ { 1 } } { l ^ { 2 } } \frac { \partial ^ { 2 } X } { \partial z ^ { 2 } } + X ^ { 2 } Y - ( β + 1 ) X + α \\ \frac { \partial Y } { \partial t } &amp; = \frac { D _ { 2 } } { l ^ { 2 } } \frac { \partial ^ { 2 } Y } { \partial z ^ { 2 } } + β X - X ^ { 2 } Y \end{aligned}\]</p><p>with Dirichlet boundary conditions</p><p class="math-container">\[\begin{array} { l } { X ( t , z = 0 ) = X ( t , z = 1 ) = α } \\ { Y ( t , z = 0 ) = Y ( t , z = 1 ) = β / α } \end{array}\]</p><p>These equations have been introduced to reproduce an oscillating chemical reaction. There is an obvious equilibrium <span>$(α, β / α)$</span>. Here, we consider bifurcations with respect to the parameter <span>$l$</span>.</p><p>We start by writing the PDE</p><pre><code class="language-julia hljs">using Revise
using BifurcationKit, LinearAlgebra, Plots, SparseArrays, Setfield, Parameters
const BK = BifurcationKit

f1(u, v) = u * u * v
norminf(x) = norm(x, Inf)

function Fbru!(f, x, p, t = 0)
	@unpack α, β, D1, D2, l = p
	n = div(length(x), 2)
	h2 = 1.0 / n^2
	c1 = D1 / l^2 / h2
	c2 = D2 / l^2 / h2

	u = @view x[1:n]
	v = @view x[n+1:2n]

	# Dirichlet boundary conditions
	f[1]   = c1 * (α	  - 2u[1] + u[2] ) + α - (β + 1) * u[1] + f1(u[1], v[1])
	f[end] = c2 * (v[n-1] - 2v[n] + β / α)			 + β * u[n] - f1(u[n], v[n])

	f[n]   = c1 * (u[n-1] - 2u[n] +  α   ) + α - (β + 1) * u[n] + f1(u[n], v[n])
	f[n+1] = c2 * (β / α  - 2v[1] + v[2])			 + β * u[1] - f1(u[1], v[1])

	for i=2:n-1
		  f[i] = c1 * (u[i-1] - 2u[i] + u[i+1]) + α - (β + 1) * u[i] + f1(u[i], v[i])
		f[n+i] = c2 * (v[i-1] - 2v[i] + v[i+1])			  + β * u[i] - f1(u[i], v[i])
	end
	return f
end

Fbru(x, p, t = 0) = Fbru!(similar(x), x, p, t)</code></pre><p>For computing periodic orbits, we will need a Sparse representation of the Jacobian:</p><pre><code class="language-julia hljs">function Jbru_sp(x, p)
	@unpack α, β, D1, D2, l = p
	# compute the Jacobian using a sparse representation
	n = div(length(x), 2)
	h = 1.0 / n; h2 = h*h

	c1 = D1 / p.l^2 / h2
	c2 = D2 / p.l^2 / h2

	u = @view x[1:n]
	v = @view x[n+1:2n]

	diag   = zeros(eltype(x), 2n)
	diagp1 = zeros(eltype(x), 2n-1)
	diagm1 = zeros(eltype(x), 2n-1)

	diagpn = zeros(eltype(x), n)
	diagmn = zeros(eltype(x), n)

	@. diagmn = β - 2 * u * v
	@. diagm1[1:n-1] = c1
	@. diagm1[n+1:end] = c2

	@. diag[1:n]    = -2c1 - (β + 1) + 2 * u * v
	@. diag[n+1:2n] = -2c2 - u * u

	@. diagp1[1:n-1] = c1
	@. diagp1[n+1:end] = c2

	@. diagpn = u * u
	return spdiagm(0 =&gt; diag, 1 =&gt; diagp1, -1 =&gt; diagm1, n =&gt; diagpn, -n =&gt; diagmn)
end</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>We could have used <code>DiffEqOperators.jl</code> like for the Swift-Hohenberg tutorial.</p></div></div><p>We shall now compute the equilibria and their stability.</p><pre><code class="language-julia hljs">n = 500

# parameters of the Brusselator model and guess for the stationary solution
par_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)
sol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))</code></pre><p>For the eigensolver, we use a Shift-Invert algorithm (see <a href="../eigensolver/#Eigen-solvers-(Eig)">Eigen solvers (Eig)</a>)</p><pre><code class="language-julia hljs">eigls = EigArpack(1.1, :LM)</code></pre><p>We continue the trivial equilibrium to find the Hopf points</p><pre><code class="language-julia hljs">opt_newton = NewtonPar(eigsolver = eigls)
opts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.01, ds = 0.001,
	pMax = 1.9, detectBifurcation = 3, nev = 21, plotEveryStep = 50,
	newtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)

	br, = @time continuation(Fbru, Jbru_sp, sol0, par_bru, (@lens _.l),
		opts_br_eq, plot = true,
		recordFromSolution = (x,p) -&gt; x[div(n,2)], normC = norminf)</code></pre><p>We obtain the following bifurcation diagram with 3 Hopf bifurcation points</p><p><img src="../bru-sol-hopf.png" alt/></p><h2 id="Normal-form-computation"><a class="docs-heading-anchor" href="#Normal-form-computation">Normal form computation</a><a id="Normal-form-computation-1"></a><a class="docs-heading-anchor-permalink" href="#Normal-form-computation" title="Permalink"></a></h2><p>We can compute the normal form of the Hopf points as follows</p><pre><code class="language-julia hljs"># we group the differentials together
jet  = BK.getJet(Fbru, Jbru_sp)

hopfpt = computeNormalForm(jet..., br, 1)</code></pre><p>and you should get</p><pre><code class="language-julia hljs">julia&gt; hopfpt
SuperCritical - Hopf bifurcation point at l ≈ 0.512353005225085.
Period of the periodic orbit ≈ 2.9370202332411925
Normal form z⋅(a⋅δp + b⋅|z|²):
(a = 0.8770732861140638 + 0.5671547647542317im, b = -0.0009380187660555578 + 0.0009391565464102912im)</code></pre><h2 id="Continuation-of-Hopf-points"><a class="docs-heading-anchor" href="#Continuation-of-Hopf-points">Continuation of Hopf points</a><a id="Continuation-of-Hopf-points-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-Hopf-points" title="Permalink"></a></h2><p>We use the bifurcation points guesses located in <code>br.specialpoint</code> to turn them into precise bifurcation points. For the second one, we have</p><pre><code class="language-julia hljs"># index of the Hopf point in br.specialpoint
ind_hopf = 2
hopfpoint, _, flag = @time newton(Fbru, Jbru_sp,
	br, ind_hopf; normN = norminf)
flag &amp;&amp; printstyled(color=:red, &quot;--&gt; We found a Hopf Point at l = &quot;, hopfpoint.p[1], &quot;, ω = &quot;, hopfpoint.p[2], &quot;, from l = &quot;, br.specialpoint[ind_hopf].param, &quot;\n&quot;)</code></pre><p>which produces</p><pre><code class="language-julia hljs">--&gt; We found a Hopf Point at l = 1.0239851696548035, ω = 2.1395092895339842, from l = 1.0353910524340078</code></pre><p>We now perform a Hopf continuation with respect to the parameters <code>l, β</code></p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>You don&#39;t need to call <code>newton</code> first in order to use <code>continuation</code>.</p></div></div><pre><code class="language-julia hljs">optcdim2 = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 6.5, pMin = 0.0, newtonOptions = opt_newton)
br_hopf, = @time continuation(Fbru, Jbru_sp,
	br, ind_hopf, (@lens _.β), optcdim2,
	normC = norminf)</code></pre><p>which gives using <code>plot(br_hopf)</code></p><p><img src="../bru-hopf-cont.png" alt/></p><h2 id="Continuation-of-periodic-orbits-(Finite-differences)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(Finite-differences)">Continuation of periodic orbits (Finite differences)</a><a id="Continuation-of-periodic-orbits-(Finite-differences)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(Finite-differences)" title="Permalink"></a></h2><p>Here, we perform continuation of periodic orbits branching from the Hopf bifurcation points.We need an educated guess for the periodic orbit which is given by <code>guessFromHopf</code>:</p><pre><code class="language-julia hljs"># number of time slices
M = 51

l_hopf, Th, orbitguess2, hopfpt, vec_hopf = guessFromHopf(br, ind_hopf,
	opts_br_eq.newtonOptions.eigsolver,
	M, 2.7; phase = 0.25)</code></pre><p>We wish to make two remarks at this point. The first is that an initial guess is composed of a space time solution and of the guess for the period <code>Th</code> of the solution. Note that the argument <code>2.7</code> is a guess for the amplitude of the orbit.</p><pre><code class="language-julia hljs"># orbit initial guess from guessFromHopf, is not a vector, so we reshape it
orbitguess_f2 = reduce(vcat, orbitguess2)
orbitguess_f = vcat(vec(orbitguess_f2), Th) |&gt; vec</code></pre><p>The second remark concerns the phase <code>0.25</code> written above. To account for the additional unknown (<em>i.e.</em> the period), periodic orbit localisation using Finite Differences requires an additional constraint (see <a href="../periodicOrbitTrapeze/#Periodic-orbits-based-on-trapezoidal-rule">Periodic orbits based on trapezoidal rule</a> for more details). In the present case, this constraint is</p><p class="math-container">\[&lt; u(0) - u_{hopf}, \phi&gt; = 0\]</p><p>where <code>u_{hopf}</code> is the equilibrium at the Hopf bifurcation and <span>$\phi$</span> is <code>real.(vec_hopf)</code> where <code>vec_hopf</code> is the eigenvector. This is akin to a Poincaré section. We do not put any constraint on <span>$u(t)$</span> albeit this is possible (see <a href="../periodicOrbitTrapeze/#Periodic-orbits-based-on-trapezoidal-rule">Periodic orbits based on trapezoidal rule</a>.</p><p>The phase of the periodic orbit is set so that the above constraint is satisfied. We shall now use Newton iterations to find a periodic orbit.</p><p>Given our initial guess, we create a (family of) problem which encodes the functional associated to finding Periodic orbits based on trapezoidal rule (see <a href="../periodicOrbitTrapeze/#Periodic-orbits-based-on-trapezoidal-rule">Periodic orbits based on trapezoidal rule</a> for more information):</p><pre><code class="language-julia hljs">poTrap = PeriodicOrbitTrapProblem(
	Fbru,    				# pass the vector field
	Jbru_sp, 				# pass the jacobian of the vector field
	real.(vec_hopf),		# used to set ϕ, see the phase constraint
	hopfpt.u,           # used to set uhopf, see the phase constraint
	M, 2n)			          # number of time slices</code></pre><p>To evaluate the functional at <code>x</code>, you call it like a function: <code>poTrap(x, par)</code> for the parameter <code>par</code>.</p><div class="admonition is-info"><header class="admonition-header">Using the functional for deflation, Fold of limit cycles...</header><div class="admonition-body"><p>The functional <code>poTrap</code> gives you access to the underlying methods to call a regular <code>newton</code>. For example the functional is <code>x -&gt; poTrap(x, par)</code> at parameter <code>par</code>. The (sparse) Jacobian at <code>(x,p)</code> is computed like this <code>poTrap(Val(:JacFullSparse), x, p)</code> while the Matrix Free version is <code>dx -&gt; poTrap((x, p, dx)</code>. This also allows you to call the newton deflated method (see <a href="../deflatedproblem/#Deflated-problems">Deflated problems</a>) or to locate Fold point of limit cycles see <a href="../library/#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>. You can also use preconditioners. In the case of more computationally intense problems (like the 2d Brusselator), this might be mandatory as using LU decomposition for the linear solve will use too much memory. See also the example <a href="../tutorialsCGL/#d-Ginzburg-Landau-equation-(finite-differences)">2d Ginzburg-Landau equation (finite differences)</a></p></div></div><p>For convenience, we provide a simplified newton / continuation methods for periodic orbits. One has just to pass a <a href="../library/#BifurcationKit.PeriodicOrbitTrapProblem"><code>PeriodicOrbitTrapProblem</code></a>.</p><pre><code class="language-julia hljs"># we use the linear solver LSFromBLS to speed up the computations
opt_po = NewtonPar(tol = 1e-10, verbose = true, maxIter = 14, linsolver = BK.LSFromBLS())
	outpo_f, _, flag = @time newton(poTrap, orbitguess_f, (@set par_bru.l = l_hopf + 0.01), 		opt_po, normN = norminf,
		linearPO = :FullSparseInplace,
		)
flag &amp;&amp; printstyled(color=:red, &quot;--&gt; T = &quot;, outpo_f[end], &quot;, amplitude = &quot;, BK.amplitude(outpo_f, n, M; ratio = 2),&quot;\n&quot;)
# plot of the periodic orbit
BK.plotPeriodicPOTrap(outpo_f, n, M; ratio = 2)</code></pre><p>and obtain</p><pre><code class="language-julia hljs">┌─────────────────────────────────────────────────────┐
│ Newton Iterations      f(x)      Linear Iterations  │
├─────────────┬──────────────────────┬────────────────┤
│       0     │       1.5225e-03     │        0       │
│       1     │       2.6324e-03     │        2       │
│       2     │       3.0558e-04     │        2       │
│       3     │       5.7499e-05     │        2       │
│       4     │       2.0407e-06     │        2       │
│       5     │       2.8184e-09     │        2       │
│       6     │       8.3969e-14     │        2       │
└─────────────┴──────────────────────┴────────────────┘
  3.210008 seconds (77.85 k allocations: 2.497 GiB, 5.42% gc time)</code></pre><p>and</p><p><img src="../PO-newton.png" alt/></p><p>Finally, we can perform continuation of this periodic orbit using the specialized call <code>continuationPOTrap</code></p><pre><code class="language-julia hljs">opt_po = @set opt_po.eigsolver = EigArpack(; tol = 1e-5, v0 = rand(2n))
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.03, ds= 0.01,
	pMax = 3.0, maxSteps = 30,
	newtonOptions = opt_po, nev = 5, precisionStability = 1e-8, detectBifurcation = 0)
br_po, = @time continuation(poTrap,
	outpo_f, (@set par_bru.l = l_hopf + 0.01), (@lens _.l),
	opts_po_cont;
	linearPO = :FullSparseInplace,
	verbosity = 2,	plot = true,
	plotSolution = (x, p;kwargs...) -&gt; heatmap!(reshape(x[1:end-1], 2*n, M)&#39;; ylabel=&quot;time&quot;, color=:viridis, kwargs...),
	normC = norminf)</code></pre><p>to obtain the period of the orbit as function of <code>l</code></p><p><img src="../bru-po-cont.png" alt/></p><h2 id="Deflation-for-periodic-orbit-problems"><a class="docs-heading-anchor" href="#Deflation-for-periodic-orbit-problems">Deflation for periodic orbit problems</a><a id="Deflation-for-periodic-orbit-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Deflation-for-periodic-orbit-problems" title="Permalink"></a></h2><p>Looking for periodic orbits branching of bifurcation points, it is very useful to use <code>newton</code> algorithm with deflation. We thus define a deflation operator (see previous example)</p><pre><code class="language-Julia hljs">deflationOp = DeflationOperator(2, (x,y) -&gt; dot(x[1:end-1], y[1:end-1]),1.0, [zero(orbitguess_f)])</code></pre><p>which allows to find periodic orbits different from <code>orbitguess_f</code>. Note that the <code>dot</code> product removes the last component, <em>i.e.</em> the period of the cycle is not considered during this particular deflation. We can now use</p><pre><code class="language-Julia hljs">outpo_f, hist, flag = @time newton(poTrap,
	orbitguess_f, (@set par_bru.l = l_hopf + 0.01), opt_po, deflationOp; linearPO = :FullSparseInplace, normN = norminf)</code></pre><h2 id="Floquet-coefficients"><a class="docs-heading-anchor" href="#Floquet-coefficients">Floquet coefficients</a><a id="Floquet-coefficients-1"></a><a class="docs-heading-anchor-permalink" href="#Floquet-coefficients" title="Permalink"></a></h2><p>A basic method for computing Floquet cofficients based on the eigenvalues of the monodromy operator is available (see <a href="../library/#BifurcationKit.FloquetQaD"><code>FloquetQaD</code></a>). It is precise enough to locate bifurcations. Their computation is triggered like in the case of a regular call to <code>continuation</code>:</p><pre><code class="language-Julia hljs">opt_po = @set opt_po.eigsolver = DefaultEig()
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.04, ds= -0.01, pMax = 3.0, maxSteps = 200, saveSolEveryStep = 1, newtonOptions = opt_po, nev = 5, precisionStability = 1e-6, detectBifurcation = 3)
br_po, = @time continuation(poTrap,
	outpo_f, (@set par_bru.l = l_hopf + 0.01), (@lens _.l),
	opts_po_cont; verbosity = 3, plot = true,
	linearPO = :FullSparseInplace,
	plotSolution = (x, p;kwargs...) -&gt; heatmap!(reshape(x[1:end-1], 2*n, M)&#39;; ylabel=&quot;time&quot;, color=:viridis, kwargs...), normC = norminf)</code></pre><p>A more complete diagram can be obtained combining the methods (essentially deflation and Floquet) described above. It shows the period of the periodic orbits as function of <code>l</code>. See <code>example/brusselator.jl</code> for more information.</p><p><img src="../bru-po-cont-3br.png" alt/></p><div class="admonition is-danger"><header class="admonition-header">Floquet multipliers computation</header><div class="admonition-body"><p>The computation of Floquet multipliers is necessary for the detection of bifurcations of periodic orbits (which is done by analyzing the Floquet exponents obtained from the Floquet multipliers). Hence, the eigensolver needs to compute the eigenvalues with largest modulus (and not with largest real part which is their default behavior). This can be done by changing the option <code>which = :LM</code> of the eigensolver. Nevertheless, note that for most implemented eigensolvers in the current Package, the proper option is set when the computation of Floquet multipliers is requested.</p></div></div><div class="admonition is-success"><header class="admonition-header">Performances</header><div class="admonition-body"><p>This example is clearly not optimized because we wanted to keep it simple. We can use a Matrix-Free version of the functional and preconditioners to speed this up. Floquet multipliers could also be computed in a Matrix-Free manner. See <code>examples/brusselator.jl</code> for more efficient methods. See also <a href="../tutorialsCGL/#d-Ginzburg-Landau-equation-(finite-differences)">2d Ginzburg-Landau equation (finite differences)</a> for a more advanced example where we introduce those methods.</p></div></div><h2 id="Continuation-of-periodic-orbits-(Standard-Shooting)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(Standard-Shooting)">Continuation of periodic orbits (Standard Shooting)</a><a id="Continuation-of-periodic-orbits-(Standard-Shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(Standard-Shooting)" title="Permalink"></a></h2><blockquote><p>Note that what follows is not really optimized on the <code>DifferentialEquations.jl</code> side. Indeed, we do not use automatic differentiation, we do not pass the sparsity pattern,...</p></blockquote><p>We now turn to a different method based on the flow of the Brusselator. To compute this flow (time stepper), we need to be able to solve the differential equation (actually a PDE) associated to the vector field <code>Fbru</code>. We will show how to do this with an implicit method <code>Rodas4P</code> from <code>DifferentialEquations.jl</code>. Note that the user can pass its own time stepper but for convenience, we use the ones in <code>DifferentialEquations.jl</code>. More information regarding the shooting method is contained in <a href="../periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a>.</p><pre><code class="language-julia hljs">n = 100

# different parameters to define the Brusselator model and guess for the stationary solution
par_bru = (α = 2., β = 5.45, D1 = 0.008, D2 = 0.004, l = 0.3)
sol0 = vcat(par_bru.α * ones(n), par_bru.β/par_bru.α * ones(n))

eigls = EigArpack(1.1, :LM)
opts_br_eq = ContinuationPar(dsmin = 0.001, dsmax = 0.00615, ds = 0.0061, pMax = 1.9,
	detectBifurcation = 3, nev = 21, plotEveryStep = 50,
	newtonOptions = NewtonPar(eigsolver = eigls, tol = 1e-9), maxSteps = 1060)

br, = @time continuation(Fbru, Jbru_sp,
	sol0, par_bru, (@lens _.l), opts_br_eq, verbosity = 0,
	plot = false,
	recordFromSolution = (x, p)-&gt;x[div(n,2)], normC = norminf)</code></pre><p>We need to create a guess for the periodic orbit. We proceed as previously:</p><pre><code class="language-julia hljs"># number of time slices
M = 10

# index of the Hopf point in the branch br
ind_hopf = 1

l_hopf, Th, orbitguess2, hopfpt, vec_hopf = BK.guessFromHopf(br, ind_hopf,
	opts_br_eq.newtonOptions.eigsolver, M, 22*0.075)
#
orbitguess_f2 = reduce(hcat, orbitguess2)
orbitguess_f = vcat(vec(orbitguess_f2), Th) |&gt; vec</code></pre><p>Let us now initiate the Standard Shooting method. To this aim, we need to provide a guess of the periodic orbit at times <span>$T/M_{sh}$</span> where <span>$T$</span> is the period of the cycle and <span>$M_{sh}$</span> is the number of slices along the periodic orbits. If <span>$M_{sh} = 1$</span>, this the Standard Simple Shooting and the Standard Multiple one otherwise. See <a href="../library/#BifurcationKit.ShootingProblem"><code>ShootingProblem</code></a> for more information.</p><pre><code class="language-julia hljs">dM = 3
orbitsection = Array(orbitguess_f2[:, 1:dM:M])

# the last component is an estimate of the period of the cycle.
initpo = vcat(vec(orbitsection), 3.0)</code></pre><p>Finally, we need to build a problem which encodes the Shooting functional. This done as follows where we first create the time stepper. For performance reasons, we rely on <code>SparseDiffTools</code></p><pre><code class="language-julia hljs">using DifferentialEquations, DiffEqOperators, SparseDiffTools, SparseArrays, DiffEqDiffTools

FOde(f, x, p, t) = Fbru!(f, x, p)

u0 = sol0 .+ 0.01 .* rand(2n)

# parameter close to the Hopf bifurcation point
par_hopf = (@set par_bru.l = l_hopf + 0.01)

jac_prototype = Jbru_sp(ones(2n), @set par_bru.β = 0)
jac_prototype.nzval .= ones(length(jac_prototype.nzval))
_colors = matrix_colors(jac_prototype)
vf = ODEFunction(FOde; jac_prototype = jac_prototype, colorvec = _colors)
prob = ODEProblem(vf,  sol0, (0.0, 520.), par_bru)</code></pre><p>We create the parallel standard shooting problem:</p><pre><code class="language-julia hljs"># this encodes the functional for the Shooting problem
probSh = ShootingProblem(
	# pass the vector field and parameter (to be passed to the vector field)
	Fbru, par_hopf,

	# we pass the ODEProblem encoding the flow and the time stepper
	prob, Rodas4P(),

	# this is for the phase condition, you can pass your own section as well
	[orbitguess_f2[:,ii] for ii=1:dM:M];

	# enable threading
	parallel = true,

	# these are options passed to the ODE time stepper
	atol = 1e-10, rtol = 1e-8)</code></pre><p>We are now ready to call <code>newton</code></p><pre><code class="language-julia hljs">ls = GMRESIterativeSolvers(reltol = 1e-7, N = length(initpo), maxiter = 100)
optn_po = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 20, linsolver = ls)
outpo, = @time newton(probSh,
	initpo, par_hopf, optn_po;
	normN = norminf)
plot(initpo[1:end-1], label = &quot;Init guess&quot;)
plot!(outpo[1:end-1], label = &quot;sol&quot;)</code></pre><p>which gives (note that we did not have a really nice guess...)</p><pre><code class="language-julia hljs">┌─────────────────────────────────────────────────────┐
│ Newton Iterations      f(x)      Linear Iterations  │
├─────────────┬──────────────────────┬────────────────┤
│       0     │       1.9613e-01     │        0       │
│       1     │       5.6101e-02     │       45       │
│       2     │       1.0307e-01     │       49       │
│       3     │       4.1119e-03     │       48       │
│       4     │       8.0511e-03     │       49       │
│       5     │       3.8250e-02     │       48       │
│       6     │       9.8080e-03     │       49       │
│       7     │       2.1179e+01     │       53       │
│       8     │       2.0105e+00     │       36       │
│       9     │       2.0545e+00     │       49       │
│      10     │       4.8793e-01     │       49       │
│      11     │       4.8457e-02     │       46       │
│      12     │       2.3299e-02     │       49       │
│      13     │       1.6365e-02     │       48       │
│      14     │       1.3534e-04     │       49       │
│      15     │       1.4582e-05     │       48       │
│      16     │       1.5886e-08     │       49       │
│      17     │       1.7228e-11     │       49       │
└─────────────┴──────────────────────┴────────────────┘
  9.706977 seconds (7.61 M allocations: 13.964 GiB, 3.62% gc time)</code></pre><p>and</p><p><img src="../brus-sh-new.png" alt/></p><p>Note that using Simple Shooting, the convergence is much faster. Indeed, running the code above with <code>dM = 10</code> gives:</p><pre><code class="language-julia hljs">┌─────────────────────────────────────────────────────┐
│ Newton Iterations      f(x)      Linear Iterations  │
├─────────────┬──────────────────────┬────────────────┤
│       0     │       6.1712e-03     │        0       │
│       1     │       3.4465e-03     │        6       │
│       2     │       1.0516e-01     │        8       │
│       3     │       7.4614e-03     │        6       │
│       4     │       1.6620e-03     │        7       │
│       5     │       3.9589e-04     │        7       │
│       6     │       4.3043e-05     │        8       │
│       7     │       1.7232e-06     │        8       │
│       8     │       8.0455e-09     │        8       │
│       9     │       3.9453e-11     │        8       │
└─────────────┴──────────────────────┴────────────────┘
  0.612070 seconds (217.21 k allocations: 523.069 MiB, 4.83% gc time)</code></pre><div class="admonition is-info"><header class="admonition-header">Convergence and speedup</header><div class="admonition-body"><p>The convergence is much worse for the multiple shooting than for the simple one. This is reflected above in the number of linear iterations made during the newton solve. The reason for this is because of the cyclic structure of the jacobian which impedes GMRES from converging fast. This can only be resolved with an improved GMRES which we&#39;ll provide in the future.</p></div></div><p>Finally, we can perform continuation of this periodic orbit using a specialized version of <code>continuation</code>:</p><pre><code class="language-julia hljs"># note the eigensolver computes the eigenvalues of the monodromy matrix. Hence
# the dimension of the state space for the eigensolver is 2n
opts_po_cont = ContinuationPar(dsmin = 0.001, dsmax = 0.05, ds= 0.01, pMax = 1.5,
	maxSteps = 500, newtonOptions = (@set optn_po.tol = 1e-7), nev = 25,
	precisionStability = 1e-8, detectBifurcation = 0)

br_po, = @time continuation(probSh,	outpo, par_hopf, (@lens _.l),
	opts_po_cont; verbosity = 2,
	# specific bordered linear solver
	linearAlgo = MatrixFreeBLS(@set ls.N = ls.N+1),
	plot = true,
	plotSolution = (x, p; kwargs...) -&gt; BK.plotPeriodicShooting!(x[1:end-1], length(1:dM:M); kwargs...),
	recordFromSolution = (u, p) -&gt; u[end], normC = norminf)</code></pre><p>We can observe that simple shooting is faster but the Floquet multipliers are less accurate than for multiple shooting. Also, when the solution is very unstable, simple shooting can have spurious branch switching. Finally, note the <span>$0=\log 1$</span> eigenvalue of the monodromy matrix in the graph below.</p><p><img src="../brus-sh-cont.png" alt/></p><h2 id="Continuation-of-periodic-orbits-(Poincaré-Shooting)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(Poincaré-Shooting)">Continuation of periodic orbits (Poincaré Shooting)</a><a id="Continuation-of-periodic-orbits-(Poincaré-Shooting)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(Poincaré-Shooting)" title="Permalink"></a></h2><p>We now turn to another Shooting method, namely the Poincaré one. We can provide this method thanks to the unique functionalities of <code>DifferentialEquations.jl</code>. More information is provided at <a href="../library/#BifurcationKit.PoincareShootingProblem"><code>PoincareShootingProblem</code></a> and <a href="../periodicOrbitShooting/#Periodic-orbits-based-on-the-shooting-method">Periodic orbits based on the shooting method</a> but basically, it is a shooting method between Poincaré sections <span>$\Sigma_i$</span> (along the orbit) defined by hyperplanes. As a consequence, the dimension of the unknowns is <span>$M_{sh}\cdot(N-1)$</span> where <span>$N$</span> is the dimension of the phase space. Indeed, each time slice lives in an hyperplane <span>$\Sigma_i$</span>. Additionally, the period <span>$T$</span> is not an unknown of the method but rather a by-product. However, the method requires the time stepper to find when the flow hits an hyperplane <span>$\Sigma_i$</span>, something called <strong>event detection</strong>.</p><p>We show how to use this method, the code is very similar to the case of the Standard Shooting. We first define the functional for Poincaré Shooting Problem</p><pre><code class="language-julia hljs"># sub-sampling factor of a initial guess for the periodic orbit
dM = 5

# vectors to define the hyperplanes Sigma_i
normals = [Fbru(orbitguess_f2[:,ii], par_hopf)/(norm(Fbru(orbitguess_f2[:,ii], par_hopf))) for ii = 1:dM:M]
centers = [orbitguess_f2[:,ii] for ii = 1:dM:M]

# functional to hold the Poincare Shooting Problem
probHPsh = PoincareShootingProblem(
	# vector field and parameter
	Fbru, par_hopf,

	# ODEProblem, ODE solver used to compute the flow
	prob, Rodas4P(),

	# parameters for the Poincaré sections
	normals, centers;

	# enable threading
	parallel = true,

	# Parameters passed to the ODE solver
	atol = 1e-10, rtol = 1e-8)</code></pre><p>Let us now compute an initial guess for the periodic orbit, it must live in the hyperplanes <span>$\Sigma_i$</span>. Fortunately, we provide projections on these hyperplanes.</p><pre><code class="language-julia hljs"># projection of the initial guess on the hyperplanes. We assume that the centers[ii]
# form the periodic orbit initial guess.
initpo_bar = reduce(vcat, BK.projection(probHPsh, centers))</code></pre><p>We can now call <code>continuation</code> to get the first branch.</p><pre><code class="language-julia hljs"># eigen / linear solver
eig = EigKrylovKit(tol= 1e-12, x₀ = rand(2n-1), dim = 40)
ls = GMRESIterativeSolvers(reltol = 1e-11, N = length(vec(initpo_bar)), maxiter = 500)

# newton options
optn = NewtonPar(verbose = true, tol = 1e-9,  maxIter = 140, linsolver = ls)

# continuation options
opts_po_cont_floquet = ContinuationPar(dsmin = 0.0001, dsmax = 0.05, ds= 0.001,
	pMax = 2.5, maxSteps = 500, nev = 10,
	precisionStability = 1e-5, detectBifurcation = 3, plotEveryStep = 3)
opts_po_cont_floquet = @set opts_po_cont_floquet.newtonOptions =
	NewtonPar(linsolver = ls, eigsolver = eig, tol = 1e-9, verbose = true)

# continuation run
br_po, = @time BK.continuation(probHPsh,
	vec(initpo_bar), par_hopf, (@lens _.l),
	opts_po_cont_floquet; verbosity = 3,
	linearAlgo = MatrixFreeBLS(@set ls.N = ls.N+1),
	plot = true,
	plotSolution = (x, p; kwargs...) -&gt; BK.plot!(x; label=&quot;&quot;, kwargs...),
	normC = norminf)		</code></pre><p><img src="../brus-psh-cont.png" alt/></p><p>We also obtain the following information:</p><pre><code class="language-julia hljs">julia&gt; br_po
Branch number of points: 41
Bifurcation points:
- #  1,    bp at p ≈ 1.20987963 ∈ (1.20128196, 1.20987963), |δp|=9e-03, [converged], δ = ( 1,  0), step =  21, eigenelements in eig[ 22], ind_ev =   1
- #  2,    ns at p ≈ 1.78687615 ∈ (1.77831727, 1.78687615), |δp|=9e-03, [converged], δ = ( 2,  2), step =  30, eigenelements in eig[ 31], ind_ev =   3
- #  3,    pd at p ≈ 1.85103701 ∈ (1.84676466, 1.85103701), |δp|=4e-03, [converged], δ = ( 1,  1), step =  31, eigenelements in eig[ 32], ind_ev =   4
- #  4,    ns at p ≈ 1.87667870 ∈ (1.86813520, 1.87667870), |δp|=9e-03, [converged], δ = ( 2,  2), step =  32, eigenelements in eig[ 33], ind_ev =   6
</code></pre></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Tuesday 17 August 2021 11:12">Tuesday 17 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
