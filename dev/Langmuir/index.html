<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1d Langmuir–Blodgett transfer model (advanced) · Bifurcation Analysis in Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="Bifurcation Analysis in Julia logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Bifurcation Analysis in Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../guidelines/">Overview</a></li><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Functionalities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../plotting/">Plotting</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Continuation methods</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../IntroContinuation/">Introduction</a></li><li><a class="tocitem" href="../Predictors/">Predictors / correctors</a></li><li><a class="tocitem" href="../PALC/">PALC</a></li><li><a class="tocitem" href="../MooreSpence/">Moore Spence Continuation</a></li><li><a class="tocitem" href="../DeflatedContinuation/">Deflated Continuation</a></li></ul></li><li><a class="tocitem" href="../EventCallback/">Event Handling and Callback</a></li><li><a class="tocitem" href="../detectionBifurcation/">Bifurcation detection (codim 1)</a></li><li><a class="tocitem" href="../codim2Continuation/">Fold / Hopf Continuation (codim 2)</a></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Normal form</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../simplebp/">Simple branch point</a></li><li><a class="tocitem" href="../nonsimplebp/">Non-simple branch point</a></li><li><a class="tocitem" href="../simplehopf/">Simple Hopf point</a></li></ul></li><li><a class="tocitem" href="../branchswitching/">Branch switching</a></li><li><a class="tocitem" href="../BifurcationDiagram/">Bifurcation diagram</a></li><li><a class="tocitem" href="../deflatedproblem/">Deflated problems</a></li><li><a class="tocitem" href="../constrainedproblem/">Constrained problem</a></li><li><input class="collapse-toggle" id="menuitem-4-11" type="checkbox"/><label class="tocitem" for="menuitem-4-11"><span class="docs-label">Periodic Orbits</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../periodicOrbit/">Introduction</a></li><li><a class="tocitem" href="../periodicOrbitTrapeze/">Finite Differences</a></li><li><a class="tocitem" href="../periodicOrbitShooting/">Shooting</a></li></ul></li><li><a class="tocitem" href="../diffeq/">DiffEq wrapper</a></li><li><a class="tocitem" href="../iterator/">Iterator Interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Options</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linearsolver/">Linear Solvers</a></li><li><a class="tocitem" href="../borderedlinearsolver/">Bordered linear solvers</a></li><li><a class="tocitem" href="../eigensolver/">Eigen Solvers</a></li><li><a class="tocitem" href="../Borderedarrays/">Bordered arrays</a></li></ul></li><li><a class="tocitem" href="../faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../library/">Library</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>1d Langmuir–Blodgett transfer model (advanced)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1d Langmuir–Blodgett transfer model (advanced)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/rveltz/BifurcationKit.jl/blob/master/docs/src/Langmuir.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="d-Langmuir–Blodgett-transfer-model-(advanced)"><a class="docs-heading-anchor" href="#d-Langmuir–Blodgett-transfer-model-(advanced)">1d Langmuir–Blodgett transfer model (advanced)</a><a id="d-Langmuir–Blodgett-transfer-model-(advanced)-1"></a><a class="docs-heading-anchor-permalink" href="#d-Langmuir–Blodgett-transfer-model-(advanced)" title="Permalink"></a></h1><p>In this tutorial, we try to replicate some of the results of the amazing paper <sup class="footnote-reference"><a id="citeref-Köpf" href="#footnote-Köpf">[Köpf]</a></sup>. This example is quite a marvel in the realm of bifurcation analysis, featuring a harp-like bifurcation diagram. The equations of the thin film are as follows:</p><p class="math-container">\[\partial_{t} c=-\partial_{x}^{2}\left[\partial_{x}^{2} c-c^{3}+c-\mu \zeta(x)\right]-V \partial_{x} c\]</p><p>with boundary conditions</p><p class="math-container">\[c(0)=c_{0}, \quad \partial_{x x} c(0)=\partial_{x} c(L)=\partial_{x x} c(L)=0\]</p><p>and where</p><p class="math-container">\[\zeta(x)=-\frac{1}{2}\left[1+\tanh \left(\frac{x-x_{s}}{l_{s}}\right)\right].\]</p><p>As can be seen in the reference above, the bifurcation diagram is significantly more involved as <span>$L$</span> increases. So we set up for the &quot;simple&quot; case <span>$L=50$</span>.</p><pre><code class="language-julia hljs">using Revise
using Parameters, Setfield, SparseArrays
using BifurcationKit, LinearAlgebra, Plots, ForwardDiff, BandedMatrices
const BK = BifurcationKit
	
# norms
norminf(x) = norm(x, Inf)
normL2(x; r = sqrt(par.Δx / L)) = norm(x, 2) * r</code></pre><p>Let us define the parameters of the model</p><pre><code class="language-julia hljs"># domain size
L = 50.0

# number of unknowns
N = 390*3/2 |&gt; Int
Δx = L/(N+1)
X = ((1:N) |&gt; collect) .* Δx

# define the (laplacian of) g function
xs = 10.0; ls = 2.0
Δg = @. tanh((X - xs)/ls) * (1 - tanh((X - xs)/ls)^2)/ls^2

# define the parameters of the model
par = (N = N, Δx = Δx, c0 = -0.9, σ = 1.0, μ = 0.5, ν = 0.08, Δg = Δg)</code></pre><h2 id="Encoding-the-PDE"><a class="docs-heading-anchor" href="#Encoding-the-PDE">Encoding the PDE</a><a id="Encoding-the-PDE-1"></a><a class="docs-heading-anchor-permalink" href="#Encoding-the-PDE" title="Permalink"></a></h2><pre><code class="language-julia hljs"># function to enforce the boundary condition
function putBC!(c, c0, N)
	# we put boundary conditions using ghost points
	# this boundary condition u&#39;&#39;(0) = 0 = c1 -2c0 + c-1 gives c-1:
	c[1] = 2c0-c[3]
	# c(0) = c0, we would like to write x[0]
	c[2] = c0
	# the boundary conditions u&#39;(L) = u&#39;&#39;(L) = 0 imply the ghost points values.
	# c&#39;(L) = 0 = cN+2 - cN  and c&#39;&#39;(L) = 0 = cN+2 -2cN+1 + cN
	c[N+3] = c[N+2]
	c[N+4] = c[N+2]
	return c
end

# implementation of the right hand side of the PDE
function Flgvf!(out, x, p, t = 0.)
	@unpack c0, N, Δx, σ, μ, Δg, ν = p
	dx4 = Δx^4
	dx2 = Δx^2
	# we declare the residual
	# we enforce the BC
	c = similar(x, length(x) + 4)
	c[3:N+2] .= x
	putBC!(c, c0, N)

	for i=3:N+2
		out[i-2] = -(σ * (c[i-2] - 4c[i-1] + 6c[i] - 4c[i+1] + c[i+2]) / dx4 +
					(c[i-1]   - 2c[i]   + c[i+1])   / (dx2) -
					(c[i-1]^3 - 2c[i]^3 + c[i+1]^3) / (dx2) -
					Δg[i-2] * μ +
					ν * (c[i+1] - c[i-1]) / (2Δx)
					)
	end
	return out
end
Flgvf(x, p, t = 0) = Flgvf!(similar(x), x, p, t)

# compute the jacobian of the PDE at position x
@views function JanaSP(x, p)
	# 63.446 μs (61 allocations: 137.97 KiB) pour N = 400
	# 62.807 μs (44 allocations: 168.58 KiB) pour sparse(Jana(x, p))
	@unpack N, Δx, σ, ν = p
	d0  = @. (-6σ/ Δx^4 + 2/ Δx^2*(1-3x^2))
	d0[1] += σ/ Δx^4
	d0[end] = -(3σ/ Δx^4 - 1/ Δx^2*(1-3x[N]^2)     + ν/ (2Δx))
	d1   = @.  (4σ/ Δx^4 - 1/ Δx^2*(1-3x[2:N]^2)   - ν/ (2Δx))
	dm1  = @.  (4σ/ Δx^4 - 1/ Δx^2*(1-3x[1:N-1]^2) + ν/ (2Δx))
	d1[end] -= σ/ Δx^4
	d2  = @.  (-σ/ Δx^4) * ones(N-2)
	J = spdiagm(  0 =&gt; d0,
				  1 =&gt; d1,
				 -1 =&gt; dm1,
				  2 =&gt; d2,
				 -2 =&gt; d2)
	return J
end</code></pre><p>It will prove useful to have access to higher derivatives as well</p><pre><code class="language-julia hljs"># jet to compute the normal form
jet  = BK.getJet(Flgvf, JanaSP)</code></pre><h2 id="Continuation-of-stationary-states"><a class="docs-heading-anchor" href="#Continuation-of-stationary-states">Continuation of stationary states</a><a id="Continuation-of-stationary-states-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-stationary-states" title="Permalink"></a></h2><p>We call the Krylov-Newton method to find a stationary solution. Note that for this to work, the guess has to satisfy the boundary conditions approximately.</p><pre><code class="language-julia hljs"># newton iterations to refine the guess
opt_new = NewtonPar(tol = 1e-9, verbose = true, maxIter = 50)
	out, = @time newton(Flgvf, JanaSP, 0X .-0.9, par, opt_new)
plot(X, out)</code></pre><p><img src="../langmuir1.png" alt/></p><p>We then continue the previous guess and find this very nice folded structure with many Hopf bifurcation points.</p><pre><code class="language-julia hljs"># careful here, in order to use Arpack.eig, you need rather big space 
# or compute ~100 eigenvalues
opts_cont = ContinuationPar(
	dsmin = 1e-5, dsmax = 0.04, ds= -0.001, pMin = -0.01, pMax = 10.1,
	# we adjust theta so that the continuation steps are larger
	theta = 0.4, a = 0.75, plotEveryStep = 30, maxSteps = 600,
	newtonOptions = setproperties(opt_new; tol = 1e-9, maxIter = 10, verbose = false),
	nev = 10, saveEigenvectors = true, precisionStability = 1e-5, detectBifurcation = 3, 
	dsminBisection = 1e-8, maxBisectionSteps = 15, nInversion = 6, tolBisectionEigenvalue = 1e-9, saveSolEveryStep = 50)

	eig = EigKrylovKit(tol=1e-9, x₀ = rand(N), dim = 150)

	@time br, u1 = @time continuation(
		Flgvf, JanaSP,
		out, (@set par.ν = 0.06), (@lens _.ν ), opts_cont,
		# we form a sparse matrix for the bordered linear problem
		linearAlgo = MatrixBLS(),
		plot = true, verbosity = 2,
		recordFromSolution = (x, p) -&gt; normL2(x),
		plotSolution = (x, p; kwargs...) -&gt; plot!(X, x, subplot = 3, xlabel = &quot;Nx = $(length(x))&quot;, label = &quot;&quot;),
		normC = normL2)</code></pre><p><img src="../langmuir2.png" alt/></p><p><img src="../langmuir3.png" alt/></p><h2 id="Continuation-of-Hopf-and-Fold-points"><a class="docs-heading-anchor" href="#Continuation-of-Hopf-and-Fold-points">Continuation of Hopf and Fold points</a><a id="Continuation-of-Hopf-and-Fold-points-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-Hopf-and-Fold-points" title="Permalink"></a></h2><p>Let us study the continuation of Hopf and Fold points and show that they merge at a <strong>Bogdanov-Takens</strong> bifurcation point:</p><pre><code class="language-julia hljs"># compute branch of Fold points from 7th bifurcation point on br
sn_codim2, = continuation(jet[1:2]..., br, 7, (@lens _.Δx), 
	ContinuationPar(opts_cont, pMin = -2, pMax = 0.12, ds = -0.01, dsmax = 0.01, precisionStability = 1e-8, maxSteps = 325, nev=23) ; 
	plot = true, verbosity = 3,
	# start the problem with information from eigen elements
	startWithEigen = true,
	# this improves tracking the Fold points
	d2F = jet[3],
	# detection of codim 2 bifurcations with bisection
	detectCodim2Bifurcation = 2,
	# we update the Fold problem at every continuation step
	updateMinAugEveryStep = 1,
	# compute both sides of the initial condition
	bothside = true
	)
	
# compute branch of Hopf points from 5th bifurcation point on br
hp_codim2, = continuation(jet[1:2]..., br, 5, (@lens _.Δx), ContinuationPar(opts_cont, pMax = 0.1, ds = -0.01, dsmax = 0.01, maxSteps = 230, precisionStability = 1e-8) ; 
	plot = true, verbosity = 3,
	# start the problem with information from eigen elements
	startWithEigen = true,
	# we update the Hopf problem at every continuation step
	updateMinAugEveryStep = 1,
	# detection of codim 2 bifurcations with bisection
	detectCodim2Bifurcation = 2,
	# this is required to detect the bifurcations
	d2F = jet[3], d3F = jet[4],
	)

# plot the branches
plot(sn_codim2, branchlabel = &quot;Fold&quot;)
plot!(hp_codim2, branchlabel = &quot;Hopf&quot;, plotcirclesbif=true)</code></pre><p><img src="../langmuirCodim2.png" alt/></p><h2 id="Continuation-of-periodic-orbits-(FD)"><a class="docs-heading-anchor" href="#Continuation-of-periodic-orbits-(FD)">Continuation of periodic orbits (FD)</a><a id="Continuation-of-periodic-orbits-(FD)-1"></a><a class="docs-heading-anchor-permalink" href="#Continuation-of-periodic-orbits-(FD)" title="Permalink"></a></h2><p>We would like to compute the branches of periodic solutions from the Hopf points. We do this automatic branch switching as follows</p><pre><code class="language-julia hljs"># parameters for newton
opt_po = NewtonPar(tol =  1e-10, verbose = true, maxIter = 50)

# parameters for continuation
opts_po_cont = ContinuationPar(dsmin = 1e-5, dsmax = 0.35, ds= 0.001,
	pMax = 1.0, maxSteps = 100, theta = 0.75,
	newtonOptions = setproperties(opt_po; maxIter = 15, tol = 1e-6), plotEveryStep = 1)

M = 100 # numbr of time sections
br_potrap, utrap = continuation(
	# arguments for branch switching
	jet..., br, 5,
	# arguments for continuation
	opts_po_cont, PeriodicOrbitTrapProblem(M = M);
	# parameter value used for branching
	δp = 1e-5, 
	# use deflated Newton to find non-trivial solutions
	usedeflation = true,
	# algorithm to solve linear associated with periodic orbit problem
	linearPO = :FullSparseInplace,
	# tangent algorithm along the branch
	tangentAlgo = BorderedPred(),
	verbosity = 3, plot = true,
	updateSectionEveryStep = 1,
	recordFromSolution = (x, p) -&gt; normL2T(x[1:end-1], M = M),
	plotSolution  = (x, p; kwargs...) -&gt; begin
			heatmap!(reshape(x[1:end-1], N, M)&#39;; ylabel=&quot;T=$(round(x[end]))&quot;, color=:viridis, kwargs...)
			plot!(br, subplot=1, label=&quot;&quot;)
		end,
	normC = norminf)</code></pre><p>and we obtain the following graph. It is interesting to note that the periodic solutions converge to an homoclinic orbit here with a very large period. <img src="../langmuir4.png" alt/></p><p>We can do this for the other Hopf points as well. Note that, we have to increase the number of time sections <code>M</code> to improve the convergence to the homoclinic orbits.</p><p><img src="../langmuir5.png" alt/></p><p>Here are some examples of periodic solutions.</p><p><img src="../langmuir6.png" alt/></p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Köpf"><a class="tag is-link" href="#citeref-Köpf">Köpf</a><blockquote><p>Köpf and Thiele, <strong>Emergence of the Bifurcation Structure of a Langmuir–Blodgett Transfer Model.</strong>, 2014</p></blockquote></li></ul></section></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Thursday 26 August 2021 15:32">Thursday 26 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
